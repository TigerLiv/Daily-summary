## Modules  

Modules are declarative;可声明的

AMD / RequireJS SimpleModule.js #
```
define(["require", "exports", "./mod"], function (require, exports, mod_1) {
    exports.t = mod_1.something + 1;
})
```
CommonJS / Node SimpleModule.js #
```
var mod_1 = require("./mod");
exports.t = mod_1.something + 1;
```

To compile, we must specify a module target on the command line. For Node.js, use --module commonjs; for require.js, use --module amd. For example:  
`tsc --module commonjs Test.ts`


Wildcard 通配符  
pitfall 陷阱  


## 命名空间  
#### Using Namespaces 
Just like all global namespace pollution, it can be hard to identify component dependencies, especially in a large application

#### Using module
Starting with ECMAScript 2015, modules are native part of the language, and should be supported by all compliant engine implementations.
#### Pitfalls of Namespaces and Modules

A common mistake is to try to use the /// <reference ... /> syntax to refer to a module file, rather than using an import statement.   

d.ts就是TypedDefinition 类型定义文件，用来定义类型信息以及接口规范。
  
Needless Namespacing #
```
export namespace Shapes {
    export class Triangle { /* ... */ }
    export class Square { /* ... */ }
}
```


```
import * as shapes from "./shapes";
let t = new shapes.Shapes.Triangle(); // shapes.Shapes?
```
### Trade-offs of Modules 模块的权衡 


### Module Resolution Strategies 

There are two possible module resolution strategies: Node and Classic. You can use the --moduleResolution flag to specify the module resolution strategy. If not specified, the default is Classic for --module AMD | System | ES2015 or Node otherwise.

