## CommonJs规范

1.为什么要有Commonjs规范

没有模块系统  
标准库较少  
没有标准接口  
缺乏包管理系统 导致js基本没有自动加载和安装依赖的能力

规范包括有模块、二进制、Buffer、字符集编码、IO流、进程环境、文件系统、套接字、单元测试、web服务器网关接口、包管理等

1.模块引用
```js
var math=require('math')
```
require接受模块标识，以此引入一个模块API到当前上下文中 

2.模块定义  
对引入的功能，上下文提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一的导出口，
在模块中存在一个module对象。他代表模块自身，而exports是module的属性。

在node中一个文件就是一个模块

3.模块标识

模块标识就是传递给require方法的参数，他必须是小驼峰命名的字符串，或者以点开头的相对路径，可以没有文件后缀名js

意义在于将类聚的方法和变量等限定在私有的作用域中，同时支持引入和导出功能以顺畅的链接上下游依赖  

commonjs构建的模块的导出和引入机制使得用户完全不必考虑变量污染


在node中模块分为两类：一类是node提供的模块，为核心模块，二十用户编写的模块，称为文件模块

     ** 核心模块在nodejs编译过程中，编译成了二进制文件，在nodeji进程启动时，部分核心模块被直接加载进内存中，所以核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径中优先判断，所以他的加载速度是最快的 **

文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。


#### 优先从缓存中加载

node对引入的模块都会进行缓存，以减少二次引入时的开销，浏览器缓存的是文件，node缓存的是编译后的对象


#### 路径分析与文件定位

. ..相对路径的文件模块  
/ 开头 绝对路径的文件模块  

核心模块的优先级仅次于缓存加载，在node编译过程中已经编译为二进制代码，其加载过程最快

在分析模块路径时，require方法会将路径转为真实路径


路径查找的规则 ： 逐级向上递归，直到根目录，层级越深越耗时。

.json之类的后缀名，在传递给require时带上扩展名，会加快一点速度，同步配合缓存，可以大幅度缓解node单线程中阻塞式调用的缺陷。


### 模块编译
每个编译成功的模块，将其文件路径作为索引在Module._cache对象上,以提高二次引入的性能

#### js模块编译

每个模块中都存在着require、exports、module这3个变量，但是他们在模块中并没有定义？

在编译过程中，Node对获取的js文件进行从头到尾的包装，在头部添加了(function (exports,require,module,__filename,__dirname){})

每个模块文件之间都进行了作用域隔离，返回一个具体的function对象
exports上的任何属性和方法都可以被外部调用，但是模块中的其余变量或属性不可被调用

#### 为何有exports，还存在module.exports
exports对象时通过形参的方式传入的，直接赋值会改变形参的引用，但不能改变作用域外的值

如果要达到require引入一个类的效果，请赋值给module.exports对象，不改变形参的引用  

exports是对module.exports的引用
```js

exports=module.exports;//对module.exports的引用

module.exports.name=''
exports.name=''
exports=function(){} //function是一块新的内存地址，导致exports和module.exports不存在任何关系，require只能有module.exports 看不到exports,所以exports是导不出去的
module.exports=function(){}

```
#### C++模块编译

Node调用process.dlopen()方法进行加载和 执行
.node文件不需要编译，因为是c++模块编译后生成的，所以这里只有加载和执行的过程

### 核心模块

