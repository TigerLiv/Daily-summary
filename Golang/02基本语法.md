```
package main

func main(){
	fmt.PrintLn("hello")
}
```
写的有些乱 之后会整理
## 注意
在go中 每个文件必须归属一个包

引入包后 就可以使用包中的函数

go build 编译

go run 直接运行

## 执行流程分析
.go文件 ----go build编译 -- 运行--结果

go run
编译运行一步

生成可执行文件 ---->没有go环境的机器上也可以运行

go run需要go环境


# 编译运行说明

指定编译的文件名
go build -o myhello hello.go

# 语法要求、注意事项

1.源代码是以.go结尾<br>
2.执行入口 main（）<br>
3.go语言严格区分大小写<br>
4.go方法是由一条条语句构成，每个语句后面不需要加分号（Go语言会在每行后自动加分号）,体现出go的简洁性<br>
5.Go编译器是一行行编译的，因此一行就写一条语句，不能写多个，否则会报错。<br>
6.go语言定义的变量或者import的包如果没有使用到，代码不能通过编译。<br>
7.大括号都是成对出现的，缺一不可。<br>

# go的转义字符
\t 一个制表位，实现对齐功能<br>
\n 换行符<br>
\\ 一个\<br>
\" 一个"<br>
\r 一个回车 fmt.Println("sdas\rd") 从当前行最开始输出，覆盖掉以前内容 fdas<br>

## go开发常见错误和解决方法

找不到文件
解决方法：源文件名不存在或者出错，或者当前路径错误
语法错误
看懂编译器的错误信息

## go注释
/* 块注释 */  // C++风格行注释


## 规范代码风格

正确的注释和注释风格<br>
正确的缩进和空白<br>
运算符两边习惯加空格<br>
一行不超80个字符 超过建议换行 <br>

## 官方编程指南
https://golang.org
## 语言标准库API
包 源文件 

Dos
Disk operating system

## 变量

 var i int = 10;

变量表示内存中的存储区域
有变量名和类型

第一种：不赋值 使用默认值 int的默认值是0

第二种：自行判断变量的类型

第三种：省略var :=
name :="tom" 等价于 var name string

第四种：多变量声明
var n1,n2,n3 int 

var n1,n2,n3 = 100,"a",66

n1,n2,n3 := 100,"a",66

声明全局变量  
函数外声明的变量就是全局变量

var (
	n1 =100
	n2 = 66
)

该区域的数值可以在同一类型范围下不断变化

var i int = 10
i = 30
i = 1.2 //不能改变类型

变量在同一个代码块里不能重名

小数默认值也是0

+号使用 
两边都是数值做加法  两边都是字符串则是拼接

## 数据类型

### 整数类型 int,int8 1字节,int16 2字节,-2^15~ 2^15 -1 int32 4字节,int64 8字节 uint 8 16 32 64 ,byte

浮点类型 float32,float64
存在+0 -0 所以 -1 

uint8 范围 0~255
int 系统32位 4个字节 系统64位 8个字节
byte 0~255
bit 计算机中最小的存储单位
1byte = 8bit

float32单精度<br>
float64双精度<br>
精度可能会有损失<br>
浮点类型默认float64 因为比float32 更精确<br>




### 查看数据类型  

%T类型 %d fmt.Printf("类型%T",n1)

字符型 没有专门的字符型，使用byte来保存单个字母字符  

GO的字符串是由字节组成 byte

当我们直接输出byte值时，会直接输出ascll码值
需要使用格式化输出  %c

保存的字符大于码值 考虑使用int类型保存
`fmt.Printf()`格式化输出

字符常量使用单引号 byte = 'a'  

英文一个字母1个字节  

汉子一个3字节  

在go中，字符本质是一个整数，直接输出时，是该字符对应的utf8编码的码值  


格式化输出%c时，会输出该数字对应的unicode字符  

字符类型是可以进行运算的，相当于一个整数，因为它都有对应的Unicode码  

`var n1 = 10 + 'a' //10 + 97 = 107`  

存储 ：字符 --对应码值---二进制 -- 存储  

读取 ：二进制 -- 码值 --- 字符 --读取  

go语言统一都用utf-8

布尔型 bool 只占1个字节

### 字符串 string

`var add string = ”hbeijing“`  

字符串一旦赋值，就不可改变 go中的字符串不可变
var str=”sdasd“
str[0]='a' //不可变

表现形式  

双引号  

反引号   
字符串原生形式输出 包括字符串 代码等  

"str3 :=`ccz `"
拼接方式 +

**字符串拼接特别长 拼接 +要留在上面**
`var str ="da"+
"da"`

### 基本数据默认值
整型 0  

浮点型 0  

字符串 ”“  

布尔值 false  

%v按照变量的值输出  


**基本数据类型转换**  

go不同类型变量都需要显示转换，就是强制转换  

数据类型不能自动转换

**基本语法**

T：数据类型  

`var i int = 100`  

i 转成float  //i 本身的数据类型并没有发生变化  

```
var n float32 = float32(i)
var n2 int8 = int8(i)
```

fmt.Printf("n = %v",n)
**int64很大的值 转换成 int8 ，它不会报错，会按溢出处理**
**因此在转换时，需要考虑范围**
```
var n1 int32 = 12
var n2 int64
var n3 int64
n3 = int64(n1) +n2
```

```
var n1 int32 =12
var n3 int8
var n4 int8
n4=int8(n1)+127 //编译通过，但是结果按溢出

n3 = int8(n1) +128//编译不通过
int32 ---int64报错
```

**基本数据类型与string的转换（重要）**

**基本类型转string**
第一种  

fmt.Sprintf("%参数"，表达式) //生成格式化字符串  

```
var num1 int =99
var num2 float64 =23.456
var b bool = true
var mychar byte = 'h'
var str string

str = fmt.Sprintf("%d", num1) //转成string 返回
str = fmt.Sprintf("%f",num2)
str = fmt.Sprintf("%t", b)
```
**第二strconv包函数**
```
var num1 int =99
var num2 float64 =23.456
var b bool = true

str = strconv.FormatInt(int64(num1),10)
str = strconv.FormatFloat(int64(num1),'f',5,64)
```
FormatBool  

f标准输出    

d 科学计数法输出  

5 保留位数  

64是float64  



**string转换基本数据类型**

strconv包里的函数

`b , _ = strconv.ParseBool(value)`  

会返回两个值
**使用 _ 忽略第二个值**
```
ParseBool(value)
ParseFloat（value,bitSize）
ParseItoa string //int转string
ParseInt(value,base,bitSize)
//base进制
bitSize 64 代表 int64 
```
**不能把字符串成功转为int时  会直接为0**
```
var a string = "hello"

var b int64



b , _=strconv.ParseInt(a,10,64)

b //0
```
```
%b 二进制输出  
%c 对应Unicode码值  
%d 十进制  
%o 八进制  
%t 布尔值
%v 默认值
%+v 类似%v，输出结构体时会添加字段名
%% 百分号
%f 小数 无指数部分
%q 有双引号输出string
```
## 复杂数据类型 
### 指针 Pointer
`var i int =10`  

 **&i输出地址**  
 
1.对于基本数据类型，变量存的就是值,  也叫值类型

2.获取变量地址  

3.指针类型 变量存的是一个地址，这个地址指向的空间存的才是值  `var ptr *int = &num`
4.获取指针类型所指向的值，使用* ，比如 `var *ptr int`,使用`*ptr获取ptr`指向的值    
指正本身也有地址  

值类型 包括 基本数据类型 int float bool string 数组和结构体  

举例说明  
```
var num int = 1
var i = 999
var ptr *int = &i
```

值类型 基本数据类型int系列，float系列，bool，string，数组，结构体struct  
变量直接存储值，内存通常在栈中分配

引用类型 指针，slice切片，map，管道chan，interface等都是引用类型  

变量存储的是一个地址，内存通常在堆上分配，当没有任何变量引用地址时，该地址对应的数据空间就成为一个垃圾，有GC来回收  

## 标识符的命名规范  
1.go对各种变量、方法等命名时使用的字符序列称为标识符  

2.凡是自己可以起名字的地方都叫标识符

英文大小写 0-9 _组成  

数字不可开头  
严格区分大小写  
标识符不能包含空格  
下划线 本身在go是一个特殊的标识符，称为空标识符。可以代表任何其他的标识符，但是它对应的值会被忽略，所以仅能作为占位符使用，不能作为标识符使用。  
不能以系统保留关键字作为标识符，比如break，if等  

包名与所在文件夹名字一样
变量名、函数名 驼峰
首字母大写可以被其他包访问（公有的），首字母小写只能本包访问（私有的）

运算符
10 / 4 会输出2  
要保留小数点 必须有浮点数参与
```
%使用
 a % b = a - a / b * b
例子 -10 % 3 = -10 - (-10)/3 * 3= -10 - -9 = -1
```
```
++ 和 -- 只能写在变量之后
自增自减只能独立使用

不能 a-- :=10
var i int = 10
var a int
++ i //error
a = i++ //error
if i++ >0 {} //error  
```  

关系运算符的结果都是bool类型

任何有值的都叫表达式
例 ： d = test() + 90

两个变量交换 不允许使用中间变量  
```
var a int = 10
var b int = 20
a= a+b 
b = a- b
a = a-b

```
go不支持三元运算符  

其他运算符
&变量地址
*变量指针取值
```
fmt.Scanln(&name)//获取一行的输入
fmt.Scanf("%s %d",&name,&age) //格式化输入
```

二进制转八进制 二进制每3为一组 从低位开始 转对应八进制  
11010110 从左边开始  
二进制转十六进制  每四位一组  

八进制转二进制 每一位对应3位的二进制  

十六进制转二进制  每一位对应4位的二进制  

### 位运算
var a int = 1 >> 2
var b int = -1 >> 2

右移 低位溢出 符号位不变 符号位补溢出的高位
左移 符号位不变 低位补0
**原码补码反码**
对于有符号的数：
1.二进制的最高位是符号位：0表示整数，1表示负数  
1===》[0000 0001] -1 [1000 0001]

2.正数的原码补码反码都一样
3.负数的反码=它的源码符号位不变，其他位取反
1 原码 [0000 0001] 反码 [0000  0001] 补码[0000 0001]
-1 原码 [1000 0001] 反码 [1111 1110] 补码 [1111 1111]
4.负数的补码=它的反码+1
5.0的反码，补码都是0
6.**在计算几运算的时候，都是以补码的方式来运算的**  
2 & 3
2 0000 0010
3 0000 0011
与 1和1 为 1  0000 0010 结果为2
^异或  1 和 0 才取1 ，否则为0 
-2^2  -4 负数 原码 -》转成反码 -》补码 计算后 在由补码转反码到原码
1111 1100 
0000 0001 相减
1111 1011         

流程控制  

1.顺序控制  
2.分支控制  
单分支    
if {}
在if中直接定义一个变量  
`if age := 20 ;age >18{}`  
双分支  
`if {} else {}`

多分支  
`if {} else if {} else {}`

`if n= false //build error `

switch分支   
switch 匹配项后面**不需要再加break**  
go中的case后表达式 可以有多个  
case后是一个表达式  有返回值的函数也可以  
case 5 //常量不能重复  
default不是必须的  
switch后面可以不带表达式 类似if-else  
```
switch {
	case age == 10 :
		fmt.Println("as")
}
```
fallthrough 默认穿透case一层 

### for循环
`for i := 0;i<=10;i++ {}`  
死循环  `for {}`  
str="sdas中文" 传统遍历会乱码 传统遍历是按照字节来遍历的 一个汉字在utf8编码是对应3个字节    
//用新的变量 `str2 = []rune(str)` //把str转成切片 
如何解决 需要将str 转成切片

for-range循环字符串 可以正常遍历汉字  按照字符来遍历  
```
for index,value:=range str {
	fmt.Printf("index=%d,val=%c",index,value)
}

for i :=0 ;i<len(str);i++
range
```
go中没有while 和 do while 
生成一个随机数，还需要rand设置一个种子
math/rand包
rand.Seed(time.Now().Unix())
n := rand.Intn(100)+1
fmt.Println(n)

break
写一个label 
break 配合标签 break label

goto可以无条件跳转到指定行
配合条件语句使用
go中不主张使用goto

函数 

func 函数名（形参列表） （返回值列表）//一个返回值可以不写（） 多个必须写{}
func test (n1 float64) float64  
包的本质创建不同的文件夹
函数名大写 
小写代表私有

包名和文件夹名保持一致
### 数组
### 结构体 struct
### 管道 channel
### 函数

函数调用机制    
go函数不支持重载
函数也是一种数据类型 也可以赋值给变量 该变量就是函数类型的变量，可以对函数进行调用
```
func a( int v){}
 b= a(v)
 b(c)  
 type 自定义数据类型，类型名
type myInt int  
var num1 myInt
var num2 int
num1 = 40 
num2 = int(num1)//转换  go认为myInt int是两个不同的类型

type myFun func(int ,int) int //myFun就是func(int ,int) int类型
```
支持对函数返回值命名

支持可变参数
```
func sum(args...int) int{}
args是slice切片 通过args[index] 可以访问个各个值
```
init函数 每一个源文件都可以包含init函数，main执行前，被go运行框架调用  
```
func init() {

}
```
init细节：
如果一个文件中同时包含全局变量定义，init函数和main函数，则执行的流程是 变量定义--init函数---main函数
init函数最主要的作用，就是完成一些初始化的工作  
匿名函数
```
如果我们某个函数只需要使用一次，可以考虑使用匿名，匿名函数可以实现多次调用
rest := func (n1 int,n2 int ) int {
	return n1+n2
}(10,20)
或者可以赋值给变量 调用变量 也可以调用函数
a:= func (n1 int ,n2 int) int {
	return n1 + n2
}
res2 := a(10,20)
```
如何把匿名函数赋给全局变量 称为全局匿名函数
var (
	Fun1 =func (n1 int ,n2 int ) int {
		return n1+n2
	}
)
调用 res4 := Fun1(10,20)


闭包 
一个函数和与其相关的引用环境组成一个整体
```
func AddUpper() func (int) int {
	//闭包  返回匿名函数 匿名函数引用到了函数外的n
	//匿名函数与n构成一个整体  构成闭包
	var n int = 10
	return func (x int) int {
		n = n + x
		return n
	}
}
```
好处  
反复调用 n只初始化一次  一直累加
参数传入一次就可以反复引用  


**defer**   
程序经常需要创建资源，为了在函数执行完毕后，销毁及时释放资源

`defer fmt.Println(1) //`
`defer fmt.Println(2) //`  
栈，先入后出，放入栈时，也会将值拷贝进栈 先输出2 在1  
变量作用域
局部变量 在函数内部
全局变量  
赋值语句不能再函数体外   
```
var Age int = 20
Name :="tome" //var Name string  Name="tome"  
```
### 字符串常用系统函数  
汉字占用3个字节  
字符串的长度 按字节 len(str)  
字符串遍历 处理有中文 r=[]rune(str) 对r遍历  
字符串转整数 n,err=strcnov.Atoi("12")  
整数转字符串 str = strconv.Itoa(12345) //输出ASCII码  
字符串转[]byte : var bytes=[]byte("hello go")  
[]byte 转字符串 str=string([]byte{97,98,98}) //a,b,c  
10进制转2，8，16进制 str=strconv.FormatInt(123,2) //2,8,16  
查找子串是否在指定的字符串中 strings.Contains("seafood","foo") //true  
统计字符串中子串 strings.Count("asd","a") //1  
不区分大小写的字符串比较 ==是区分大小写的  strings.EqualFold("abc","ABC")//不区分大小写   
返回子串第一次出现的index值 如果没有返回-1  
strings.Index("NLT_abc","abc") //4    
strings.LastIndex("go lang","go") //0    
指定字符串替换为另一个子串 strings.Replace("go golang","go","li",n) n可以指定替换几个 n=-1表示全部替换   
将字符串按分割符拆分成字符串数组  
strArr :=strings.Split("hello,world",",")   
对字符串进行大小写转换 
``` 
strings.ToUpper("go") //GO 
strings.ToLower("GO") //go  
```
左右两边的空格去掉 
`strings.TrimSpace(" sda ") //sda  `
**原先的字符串没有变化返回新串**   
将字符串指定两边的字符去掉  
`strings.Trim("! hello "," ! " ) //只能去掉左右两边`
将左边的指定字符去掉  
`strings.TrimLeft() strings.TrimRight()`

判断字符串是否以指定的字符串开头：`strings.HasPrefix("ftp:999","ftp")//true`  
判断字符串是否以指定字符串结束:`string.HasSuffix("dasdas","z")`
  
### 时间和日期函数  
导入time包  
获取当前时间  
now :=time.Now()  
其他日期  
now.Year()  now.Month() now.Day() now.Hour()  
int(noww.Month) //英文转数字  
格式化日期时间  
使用Printf或者Sprintf（返回字符串） 
now.Format("2006/01/02 15:04:05") //固定写法  
01就是月  传入什么返回什么  

func Sleep(d Duration)  
时间常量  
time.Second 1秒  
time.Sleep(100*time.MilliSecond)//休眠100毫秒   
随机数  
Unix（）返回1970年到现在的秒数 UnixNano() 1970年到现在的纳米秒数   
now.Unix() now.UnixNano()  
time.Noew().Unix() //获取当前unix的时间戳  


### 内置函数  

new() 分配内存 用来分配值类型 返回值是指正  
num1 := 100  
num2 :=new(int) //*int  
*num2 =100  
num2是一个地址（系统分配）   &num2的地址  
make用来分配内存 分配引用类型 channel map  

### 错误处理  
不支持trycatch  
go中的处理方式为defer，panic，recover  
抛出一个panic异常，然后在defer中使用recover来处理异常   
defer+recover   
```
defer func(){
	err :=recover()//内置函数可以捕获到异常
	if err != nil{
		//说明捕获到异常
	}
}()  
```
**自定义错误**  
使用errors.New 和panic内置函数  
errors.New("错误变量") 会返回一个error类型 表示一个错误  
panic内置函数 接受一个interface{}类型的值（也就是任何值）作为参数，可以接受error类型的变量，输出错误信息，并退出程序  
`panic(err)`//退出程序，后续代码不执行  

### 数组

### 切片 slice
### 接口 Interface
### map






































