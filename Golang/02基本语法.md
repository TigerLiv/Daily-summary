package main

func main(){
	fmt.PrintLn("hello")
}

在go中 每个文件必须归属一个包

引入包后 就可以使用包中的函数

go build 编译

go run 直接运行

# 执行流程分析
.go文件 ----go build编译 -- 运行--结果

go run
编译运行一步

生成可执行文件 ---->没有go环境的机器上也可以运行

go run需要go环境


# 编译运行说明

指定编译的文件名
go build -o myhello hello.go

# 语法要求、注意事项

源代码是以.go结尾
执行入口 main（）
go语言严格区分大小写
go方法是由一条条语句构成，每个语句后面不需要加分号（Go语言会在每行后自动加分号）,体现出go的简洁性
Go编译器是一行行编译的，因此一行就写一条语句，不能写多个，否则会报错。
go语言定义的变量或者import的包如果没有使用到，代码不能通过编译。
大括号都是成对出现的，缺一不可。

# go的转义字符
\t 一个制表位，实现对齐功能
\n 换行符
\\ 一个\
\" 一个"
\r 一个回车 fmt.Println("sdas\rd") 从当前行最开始输出，覆盖掉以前内容 fdas

# go开发常见错误和解决方法

找不到文件
解决方法：源文件名不存在或者出错，或者当前路径错误
语法错误
看懂编译器的错误信息

# go注释
/* 块注释 */  // C++风格行注释


# 规范代码风格

正确的注释和注释风格
正确的缩进和空白
运算符两边习惯加空格
一行不超80个字符 超过建议换行 

# 官方编程指南
https://golang.org
# 语言标准库API
包 源文件 

# Dos常用指令
Disk operating system

# 变量

 var i int = 10;

变量表示内存中的存储区域
有变量名和类型


第一种：不赋值 使用默认值 int的默认值是0

第二种：自行判断变量的类型

第三种：省略var :=
name :="tom" 等价于 var name string

第四种：多变量声明
var n1,n2,n3 int 

var n1,n2,n3 = 100,"a",66

n1,n2,n3 := 100,"a",66

声明全局变量  
函数外声明的变量就是全局变量

var (
	n1 =100
	n2 = 66
)

该区域的数值可以在同一类型范围下不断变化

var i int = 10
i = 30
i = 1.2 //不能改变类型

变量在同一个代码块里不能重名

小数默认值也是0

+号使用 
两边都是数值做加法  两边都是字符串则是拼接

# 数据类型

整数类型 int,int8 1字节,int16 2字节,-2^15~ 2^15 -1 int32 4字节,int64 8字节 uint 8 16 32 64 ,byte
浮点类型 float32,float64
存在+0 -0 所以 -1 
uint8 范围 0~255
int 系统32位 4个字节 系统64位 8个字节
byte 0~255
bit 计算机中最小的存储单位
1byte = 8bit

float32单精度
float64双精度
精度可能会有损失
浮点类型默认float64 因为比float32 更精确




查看数据类型
%T类型 %d fmt.Printf("类型%T",n1)

字符型 没有专门的字符型，使用byte来保存单个字母字符
GO的字符串是由字节组成 byte

当我们直接输出byte值时，会直接输出ascll码值
需要使用格式化输出  %c

保存的字符大于码值 考虑使用int类型保存
fmt.Printf()格式化输出

字符常量使用单引号 byte = 'a'
英文一个字母1个字节
汉子一个3字节
在go中，字符本质是一个整数，直接输出时，是该字符对应的utf8编码的码值

格式化输出%c时，会输出该数字对应的unicode字符
字符类型是可以进行运算的，相当于一个整数，因为它都有对应的Unicode码
var n1 = 10 + 'a' //10 + 97 = 107
存储 ：字符 --对应码值---二进制 -- 存储
读取 ：二进制 -- 码值 --- 字符 --读取
go语言统一都用utf-8

布尔型 bool

只占1个字节

字符串 string

var add string = ”hbeijing“
字符串一旦赋值，就不可改变 go中的字符串不可变
var str=”sdasd“
str[0]='a' //不可变

表现形式
双引号
反引号 字符串原生形式输出 包括字符串 代码等
str3 :=`ccz `
拼接方式 +

字符串拼接特别长 拼接 +要留在上面
var str ="da"+
"da"

基本数据默认值
整型 0
浮点型 0
字符串 ”“
布尔值 false
%v按照变量的值输出

基本数据类型转换
go不同类型变量都需要显示转换，就是强制转换
数据类型不能自动转换

基本语法

T：数据类型
var i int = 100
i 转成float  //i 本身的数据类型并没有发生变化
var n float32 = float32(i)
var n2 int8 = int8(i)

fmt.Printf("n = %v",n)
int64很大的值 转换成 int8 ，它不会报错，会按溢出处理
因此在转换时，需要考虑范围
var n1 int32 = 12
var n2 int64
var n3 int64
n3 = int64(n1) +n2


var n1 int32 =12
var n3 int8
var n4 int8
n4=int8(n1)+127 //编译通过，但是结果按溢出

n3 = int8(n1) +128//编译不通过
int32 ---int64报错


基本数据类型与string的转换（重要）

基本类型转string
第一种
fmt.Sprintf("%参数"，表达式) //生成格式化字符串

var num1 int =99
var num2 float64 =23.456
var b bool = true
var mychar byte = 'h'
var str string

str = fmt.Sprintf("%d", num1) //转成string 返回
str = fmt.Sprintf("%f",num2)
str = fmt.Sprintf("%t", b)

第二种
strconv包函数

var num1 int =99
var num2 float64 =23.456
var b bool = true

str = strconv.FormatInt(int64(num1),10)
str = strconv.FormatFloat(int64(num1),'f',5,64)
FormatBool
f标准输出  
d 科学计数法输出
5 保留位数
64是float64


string转换基本数据类型

strconv包里的函数

b , _ = strconv.ParseBool(value)
会返回两个值
使用 _ 忽略第二个值

ParseBool(value)
ParseFloat（value,bitSize）
ParseItoa string //int转string
ParseInt(value,base,bitSize)
base进制
bitSize 64 代表 int64 

不能把字符串成功转为int时  会直接为0
var a string = "hello"

var b int64



b , _=strconv.ParseInt(a,10,64)

b //0



%b 二进制输出
%c 对应Unicode码值
%d 十进制
%o 八进制
%t 布尔值
%v 默认值
%+v 类似%v，输出结构体时会添加字段名
%% 百分号
%f 小数 无指数部分
%q 有双引号输出string

复杂数据类型 
指针 Pointer
数组
结构体 struct
管道 channel
函数
切片 slice
接口 Interface
map






































