> #### 先说说这三者的区别吧：
> * var 和 let 用以声明变量，const 用于声明只读的常量；
> * var 声明的变量，不存在块级作用域，在全局范围内都有效，let 和 const 声明的，只在它所在的代码块内有效；
> * let 和 const 不存在像 var 那样的 [“变量提升”](https://www.jianshu.com/p/d4b88723cd12) 现象，所以 var 定义变量可以先使用，后声明，而 let 和 const 只可先声明，后使用；
> * let 声明的变量存在暂时性死区，即只要块级作用域中存在 let，那么它所声明的变量就绑定了这个区域，不再受外部的影响。
> * let 不允许在相同作用域内，重复声明同一个变量；
> * const 在声明时必须初始化赋值，一旦声明，其声明的值就不允许改变，更不允许重复声明；
>   > 如 const 声明了一个复合类型的常量，其存储的是一个引用地址，不允许改变的是这个地址，而对象本身是可变的。
> 
> 变量与内存之间的关系，主要由三个部分组成：
> 
> 1. 变量名
> 2. 内存地址
> 3. 内存空间
> 
> JS 引擎在读取变量时，先找到变量绑定的内存地址，然后找到地址所指向的内存空间，最后读取其中的内容。当变量改变时，JS 引擎不会用新值覆盖之前旧值的内存空间（虽然从写代码的角度来看，确实像是被覆盖掉了），而是重新分配一个新的内存空间来存储新值，并将新的内存地址与变量进行绑定，JS 引擎会在合适的时机进行 GC，回收旧的内存空间。
> 
> const 定义变量（常量）后，变量名与内存地址之间建立了一种不可变的绑定关系，阻隔变量地址被改变，当 const 定义的变量进行重新赋值时，根据前面的论述，JS 引擎会尝试重新分配新的内存空间，所以会被拒绝，便会抛出异常。
> 


var：遇到有var的作用域，在任何语句执行前都已经完成了声明和初始化，也就是变量提升而且拿到undefined的原因由来  
function： 声明、初始化、赋值一开始就全部完成，所以函数的变量提升优先级更高  
let：解析器进入一个块级作用域，发现let关键字，变量只是先完成声明，并没有到初始化那一步。此时如果在此作用域提前访问，则报错xx is not defined，这就是暂时性死区的由来。等到解析到有let那一行的时候，才会进入初始化阶段。如果let的那一行是赋值操作，则初始化和赋值同时进行  
const、class都是同let一样的道理