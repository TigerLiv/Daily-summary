```js
var a = {n:1};  
var b = a; // 持有a，以回查  
a.x = a = {n:2};  
alert(a.x);// --> undefined  
alert(b.x);// --> {n:2}
```

a = a.x = {n:2}和a.x = a = {n:2}的结果是一致的原因是，属性访问表达式优先级高于“=”号，无论哪种赋值方式都是先执行a.x，所以a 指向是{n:1}，添加属性x之后,被重新赋值{n:2}对象。



```js
var a = {n:1}; 
/*定义a，a赋值为`{n:1}`；
为a在内存堆中分配一块内存用于存储`{n:1}`，假设其地址为add_1；
此时add_1引用计数为1，即a，内容为`{n:1}`。*/ 
var b = a; 
/*定义b，b赋值a，add_1被b引用。
此时add_1引用计数为2，即a和b，内容为`{n:1}`。*/  
a.x = a = {n:2};
/*（`=`赋值运算符：关联性为从右向左，优先级为3。`.`成员访问运算符：关联性为从左向右，优先级为19。19>3，所以先计算成员访问运算符）
（1）：a.x是成员访问运算表达式，a.x中的x赋值为`a = {n:2}`的返回值`{n:2}`，add_1被改写`{n:1,x:{n:2}}`。
此时add_1引用计数为2，即a、b，内容为`{n:1,x:{n:2}}`。
（2）：a赋值为`{n:2}`；
为a在内存堆中分配一块内存用于存储`{n:2}`，假设其地址为add_2；
此时add_1引用计数为1，即b，内容为`{n:1,x:{n:2}}`。
此时add_2引用计数为1，即a，内容为`{n:2}`。*/ 
alert(a.x);
/*现在a的存储地址add_2，内容为{n:2}，上面并不存在a.x属性，所以为undefined*/ 
alert(b.x);
/*现在b的存储地址add_1，内容为{n:1,x:{n:2}}，所以b.x为{n:2}*/ 
```