## patch介绍
虚拟dom最核心的部分是patch，他可以将vnode渲染成真实dom
patch也可以叫patching算法，通过它渲染真实dom时，并不是暴力覆盖原有的dom，而是比对新旧两个vnode之间有哪些不同，然后根据对比结果找出需要更新的节点进行更新。其作用就是在现有dom上进行修改来实现更新视图的目的。

对dom进行修改需要做三件事：
1.创建新增的节点
2.删除已经废弃的节点
3.修改需要更新的节点
最终目的是渲染视图
当oldvonde和vnode不一样时，以vnode为准来渲染视图

### 7.11创建节点
新增节点 什么情况新增节点  当oldvnode不存在 时，而vnode存在时，就需要使用vnode生成真实的dom节点并将其插入到视图中去

通常发生在首次渲染中，因为首次渲染中，dom中不存在任何节点，所以oldvnode是不存在的
当vnode和oldvnode完全不是同一个节点，需要使用vnode生成真实的dom元素并将其插入到视图中
以vnode为标准来渲染视图，得知vnode是一个全新的节点，而oldvnode就是一个被废弃的节点

### 7.12删除节点

当前节点只在oldvnode中存在时，我们需要把他从dom删除，因为渲染时以vnode为标准，所以vnode中不存在的节点都属于被废弃的节点，而被废弃的节点需要从dom中删除

### 7.13更新节点

当我们需要以新节点为标准渲染视图，所以这个时候只有两种操作可以执行：将旧节点删除或者创建新增节点

### 7.2创建节点

事实上只有三种类型的节点会被创建并插入到dom中：元素节点、注释节点、文本节点
判断vnode是否为元素节点，只需要判断它是否具有tag属性，就可以调用createElement方法来创建真实的元素节点

将元素渲染到视图的过程非常简单，只需要调用appendchild方法，在浏览器环境下就是调用parentNode.appendChild，就可以讲一个元素插入到指定的父节点中，如果这个指定的父节点已经被渲染到视图，那么把元素插入到它的下面将会自动将元素渲染到视图

创建子节点的过程实际是一个递归的过程，vnode中的children属性保存了当前节点的所有子虚拟节点，所以只需要将vnode中的children属性循环一遍，将每个子虚拟节点都执行一遍创建元素的逻辑，就可以实现我们想要的功能

在创建节点时，如果不存在tag标签  可能是注释节点和文本节点，注释节点有唯一的属性isComment 就可以判断它是否为注释节点。

如果是文本节点则调用createTextNode方法来创建真实的文本节点将他插入到指定的父节点中

如果是注释节点，则调用createComment方法，插入到指定的父节点中。

### 7.3删除节点

删除是从vnodes数组 startidx指定位置endidx指定位置的内容

封装removeChild原因  是因为为了跨平台  框架渲染机制与dom解耦

### 7.4更新节点

#### 7.4.1静态节点
静态节点 不会因为状态的变化而发生变化

这就是为什么需要判断虚拟节点是否是静态节点，从而跳过更新节点的步骤

#### 7.4.2新虚拟节点有文本属性

当新旧两个静态节点时，根据新节点的vnode是否有text属性，更新节点可以分为两种不同情况

如果生成的虚拟节点有text属性，那么不论之前旧节点的子节点是什么，直接setTextContent方法来讲=将视图中dom节点内容改为虚拟节点text属性保存的文字

如果之前的旧节点也是文本，并且和新节点的文本相同，那么不要执行setTextContent方法来重复设置相同的文本。

### 7.4.3新虚拟节点无文本属性

如果新虚拟节点没有text属性，那么他就是一个元素节点。元素通常会有子节点，也就是children属性，但也有可能没有子节点，所以存在两种不同情况。
1.有children情况
当新创建的虚拟节点有children属性时，其实还会有两种情况，那就要看旧虚拟节点是否有children属性。
如果旧虚拟节点有children属性 ，需要进行更详细的对比并更新，更新children可能会移动某个子节点位置，也有可能会删除或新增某个子节点
如果旧虚拟节点没有children属性，要么是一个空标签，要么是一个有文本的文本标签，如果是文本节点，先把文本清空让他变为空标签，然后将虚拟节点中children挨个创建真实dom插入到视图中dom节点下面  

2.无children情况
当新创建的虚拟节点既没有text属性也没有children属性时，说明这个新创建的节点是一个空节点，它下面即没有文本也没有子节点，这时如果旧虚拟节点中有子节点就删除子节点，有文本就删除文本


